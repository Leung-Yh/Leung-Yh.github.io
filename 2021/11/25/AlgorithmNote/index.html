

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon/myfavicon.png">
  <link rel="icon" href="/img/icon/myfavicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Leungyh">
  <meta name="keywords" content="">
  
    <meta name="description" content="排序归并排序递归实现1234567891011121314151617181920212223242526272829303132int length &#x3D; 100;int data[length];void Merge(int first, int mid, int last)&amp;#123;    int *temp &#x3D; new int[length];	&#x2F;&#x2F;数组temp作为合并的辅助空间（用new">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm">
<meta property="og:url" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/index.html">
<meta property="og:site_name" content="Leungyh&#39;s blog">
<meta property="og:description" content="排序归并排序递归实现1234567891011121314151617181920212223242526272829303132int length &#x3D; 100;int data[length];void Merge(int first, int mid, int last)&amp;#123;    int *temp &#x3D; new int[length];	&#x2F;&#x2F;数组temp作为合并的辅助空间（用new">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/image-20220930093303598.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/image-20220930093457079.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/image-20220930093601245.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/image-20220930093807355.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140725231726921">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721222801918">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140723224710203">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140726213602848">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721223809617">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721223539765">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721223823548">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721223558140">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721223611515">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721230517324">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721230250468">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140728110939595">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721223809617-1664502783904">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721223539765-1664502831947">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140729182154066">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140729181940812">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20150812214857858">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721231622000">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140723224710203-1664503719079">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140726213602848-1664503828241">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721223809617-1664503879513">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721223539765-1664503894803">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721223823548-1664503912612">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721223558140-1664503928624">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140721223611515-1664503944938">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTA2LzE0LzgzOTQzMjNfMTMwODA3NTg1OVpmdWUuanBn.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTA2LzE0LzgzOTQzMjNfMTMwODA3NTg1OTFreVYuanBn.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/20140801160510832-1664504307010">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTA2LzE0LzgzOTQzMjNfMTMwODA3NTg1NzE0bFcuanBn.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTA2LzE0LzgzOTQzMjNfMTMwODA3NTg1NzEzOTAuanBn.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTA2LzE0LzgzOTQzMjNfMTMwODA3NTg1N2U0MHUuanBn.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/v2-6d6a40331cd9e44bfccd27ac5a764618_720w.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/v2-c5ff4faaab9c3e13690deb86d8d17d71_720w.webp">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/image-20221111114926574.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/image-20221111115011223.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/image-20221111115053104.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/image-20221111115111128.png">
<meta property="og:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/image-20221111115126718.png">
<meta property="article:published_time" content="2021-11-25T10:19:32.000Z">
<meta property="article:modified_time" content="2023-07-04T13:40:57.602Z">
<meta property="article:author" content="Leungyh">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://leung-yh.github.io/2021/11/25/AlgorithmNote/image-20220930093303598.png">
  
  
  
  <title>Algorithm - Leungyh&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"leung-yh.github.io","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Leungyh&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Algorithm"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-11-25 18:19" pubdate>
          2021年11月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          38k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          319 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Algorithm</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2023年7月4日 晚上
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> length = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> data[length];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> last)</span></span>&#123;<br>    <span class="hljs-type">int</span> *temp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[length];	<span class="hljs-comment">//数组temp作为合并的辅助空间（用new开辟到堆中防止栈溢出）</span><br>    <span class="hljs-type">int</span> i = first, j = mid+<span class="hljs-number">1</span>, k = first;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid+<span class="hljs-number">1</span> &amp;&amp; j &lt;= last)&#123;<br>        <span class="hljs-keyword">if</span>(data[i] &lt;= data[j])&#123;<br>            temp[k++] = data[i++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            temp[k++] = data[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid)&#123;<br>        temp[k++] = data[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j &lt;= last)&#123;<br>        temp[k++] = data[j++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = first; i &lt;= last; i++)&#123;<br>        data[i] = temp[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> last)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(first == last) <span class="hljs-keyword">return</span>;    	<span class="hljs-comment">//只有1个记录时，递归结束</span><br>    <span class="hljs-type">int</span> mid = (first + last) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">MergeSort</span>(first, mid);			<span class="hljs-comment">//归并排序前半个子序列</span><br>    <span class="hljs-built_in">MergeSort</span>(mid+<span class="hljs-number">1</span>, last);			<span class="hljs-comment">//归并排序后半个子序列</span><br>    <span class="hljs-built_in">Merge</span>(first, mid, last);		<span class="hljs-comment">//将两个已排序的子序列合并</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> length = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> data[length];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> last)</span></span>&#123;<br>    <span class="hljs-type">int</span> *temp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[length];	<span class="hljs-comment">//数组temp作为合并的辅助空间（用new开辟到堆中防止栈溢出）</span><br>    <span class="hljs-type">int</span> i = first, j = mid+<span class="hljs-number">1</span>, k = first;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid+<span class="hljs-number">1</span> &amp;&amp; j &lt;= last)&#123;<br>        <span class="hljs-keyword">if</span>(data[i] &lt;= data[j])&#123;<br>            temp[k++] = data[i++];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            temp[k++] = data[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid)&#123;<br>        temp[k++] = data[i++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(j &lt;= last)&#123;<br>        temp[k++] = data[j++];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i = first; i &lt;= last; i++)&#123;<br>        data[i] = temp[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergePass</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i+<span class="hljs-number">2</span>*h &lt;= length)&#123;<br>        <span class="hljs-built_in">Merge</span>(i, i+h<span class="hljs-number">-1</span>, i+<span class="hljs-number">2</span>*h<span class="hljs-number">-1</span>);<br>        i = i+<span class="hljs-number">2</span>*h;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i+h &lt; length)&#123;<br>        <span class="hljs-built_in">Merge</span>(i, i+h<span class="hljs-number">-1</span>, length<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(h &lt; length)&#123;<br>        <span class="hljs-built_in">MergePass</span>(h);<br>        h = <span class="hljs-number">2</span>*h;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>













<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    ListNode *p1 = head, *p2 = <span class="hljs-literal">NULL</span>;<br>    ListNode *tmp;<br>    <span class="hljs-keyword">while</span>(p1!=<span class="hljs-literal">NULL</span>)&#123;<br>        tmp = p1-&gt;next;<br>        p1-&gt;next = p2;<br>        p2 = p1;<br>        p1 = tmp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p2;<br>&#125;<br></code></pre></td></tr></table></figure>









































































<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>string <span class="hljs-keyword">operator</span>+(string h1, string h2)<br>&#123;<br>    string temp;<br>    <span class="hljs-built_in">reverse</span>(h1.<span class="hljs-built_in">begin</span>(), h1.<span class="hljs-built_in">end</span>());           <span class="hljs-comment">//字符串反转</span><br>    <span class="hljs-built_in">reverse</span>(h2.<span class="hljs-built_in">begin</span>(), h2.<span class="hljs-built_in">end</span>());           <span class="hljs-comment">//字符串反转</span><br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">max</span>(h1.<span class="hljs-built_in">length</span>(), h2.<span class="hljs-built_in">length</span>()); <span class="hljs-comment">//取最长的为长度</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x3 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; temp.<span class="hljs-built_in">length</span>())<br>            x3 = <span class="hljs-built_in">int</span>(temp[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//取出当前位数字</span><br>        <span class="hljs-type">int</span> x1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; h1.<span class="hljs-built_in">length</span>())<br>            x1 = <span class="hljs-built_in">int</span>(h1[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//取出第一个加数的当前位数字</span><br>        <span class="hljs-type">int</span> x2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (i &lt; h2.<span class="hljs-built_in">length</span>())<br>            x2 = <span class="hljs-built_in">int</span>(h2[i] - <span class="hljs-string">&#x27;0&#x27;</span>); <span class="hljs-comment">//取出第二个加数的当前位数字</span><br>        x3 = x3 + x1 + x2;<br>        string x = <span class="hljs-built_in">to_string</span>(x3);<br>        <span class="hljs-built_in">reverse</span>(x.<span class="hljs-built_in">begin</span>(), x.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// x应该先反转再加上去</span><br>        temp.<span class="hljs-built_in">erase</span>(i, <span class="hljs-number">1</span>);            <span class="hljs-comment">//先删除当前位的数字</span><br>        temp.<span class="hljs-built_in">insert</span>(i, x);           <span class="hljs-comment">//把当前位的计算结果的拼接回去</span><br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">//返回前先反转回来</span><br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string h = <span class="hljs-string">&quot;0&quot;</span>;<br>    string h1;<br>    string h2;<br>    cin &gt;&gt; h1 &gt;&gt; h2;<br>    h = h1 + h2;<br>    cout &lt;&lt; h &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> num[<span class="hljs-number">10010</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp;<br>    temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perm</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (now &gt;= len)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        &#123;<br>            cout &lt;&lt; num[i];<br>        &#125;<br>        cout &lt;&lt; endl;<br>        n++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = now; i &lt; len; i++)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(num[now], num[i]);<br>        <span class="hljs-built_in">perm</span>(now + <span class="hljs-number">1</span>, len);<br>        <span class="hljs-built_in">swap</span>(num[now], num[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>    &#123;<br>        num[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">perm</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;全排列的个数为：&quot;</span> &lt;&lt; n &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="繁殖（递归思路启发）"><a href="#繁殖（递归思路启发）" class="headerlink" title="繁殖（递归思路启发）"></a>繁殖（递归思路启发）</h3><p>某种单细胞生物采用分裂繁殖，每次可以分裂成两个相同大小的子体，子体可以继续如此分裂，当能量为1时停止。<br>该生物一开始有能量n，可以分裂成小于等于n的一半能量（整数）的个体，如果能量大于1，可以继续分裂繁殖。也可能直接分裂成两个能量为1的个体，立刻停止繁殖。<br>例如起始能量为10的生物，可以有这样的繁殖路径<br>10   1<br>10  2  1<br>10  3   1<br>10  4   1<br>10  5   1<br>10  4  2  1<br>10  5  2   1<br>输入一个表示生物起始能量的整数n（小于100）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; num;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> nowEnergy)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//当能量大小为1时，不能继续分裂，结束</span><br>    <span class="hljs-keyword">if</span> (nowEnergy == <span class="hljs-number">1</span>)<br>    &#123;<br>        ans.<span class="hljs-built_in">push_back</span>(num);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//当能量大小为nowEnergy时，下一次分裂有nowEnergy种选择</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= nowEnergy / <span class="hljs-number">2</span>; i++) <br>    &#123;<br>        num.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-built_in">dfs</span>(i);<br>        num.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    num.<span class="hljs-built_in">push_back</span>(n);<br>    <span class="hljs-built_in">dfs</span>(n);<br>    <span class="hljs-type">int</span> ansNum = ans.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ansNum; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> ansLen = ans[i].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; ansLen; j++)<br>        &#123;<br>            cout &lt;&lt; ans[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveplate</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; from &lt;&lt; <span class="hljs-string">&quot;--&gt;&quot;</span> &lt;&lt; to &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> from, <span class="hljs-type">char</span> to, <span class="hljs-type">char</span> temp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">moveplate</span>(n, from, to); <br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">hanoi</span>(n - <span class="hljs-number">1</span>, from, temp, to); <span class="hljs-comment">//把上面的n-1个盘子从from移到temp</span><br>    <span class="hljs-built_in">moveplate</span>(n, from, to);<br>    <span class="hljs-built_in">hanoi</span>(n - <span class="hljs-number">1</span>, temp, to, from); <span class="hljs-comment">//把上面的n-1个盘子从temp移到to</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">char</span> from = <span class="hljs-string">&#x27;A&#x27;</span>, temp = <span class="hljs-string">&#x27;B&#x27;</span>, to = <span class="hljs-string">&#x27;C&#x27;</span>;<br>    <span class="hljs-built_in">hanoi</span>(n, from, to, temp);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h3><p>[P1219] <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1219">USACO1.5]八皇后 Checker Challenge - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> line[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//行</span><br><span class="hljs-type">int</span> col[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//列</span><br><span class="hljs-type">int</span> leftUp[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//左上到右下</span><br><span class="hljs-type">int</span> rightUp[<span class="hljs-number">100</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//右上到左下</span><br><br><span class="hljs-type">int</span> tot;  <span class="hljs-comment">//解的总数</span><br><span class="hljs-type">int</span> n;  <span class="hljs-comment">//n*n个格子</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(r&gt;n)<br>    &#123;<br>        tot++;<br>        <span class="hljs-keyword">if</span>(tot&lt;=<span class="hljs-number">3</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>                cout&lt;&lt;line[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            cout&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> c=<span class="hljs-number">1</span>;c&lt;=n;c++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!col[c] &amp;&amp; !leftUp[r-c+n] &amp;&amp; !rightUp[r+c])<br>        &#123;<br>            line[r] = c;  <span class="hljs-comment">//把皇后放在[r,c]上</span><br>            col[c] = <span class="hljs-number">1</span>;  <span class="hljs-comment">//占领该列</span><br>            leftUp[r-c+n] = <span class="hljs-number">1</span>;  <span class="hljs-comment">//占领该主对角线</span><br>            rightUp[r+c] = <span class="hljs-number">1</span>;  <span class="hljs-comment">//占领该副对角线</span><br>            <span class="hljs-built_in">DFS</span>(r+<span class="hljs-number">1</span>);  <span class="hljs-comment">//DFS</span><br>            <span class="hljs-comment">//回溯</span><br>            col[c] = <span class="hljs-number">0</span>;<br>            leftUp[r-c+n] = <span class="hljs-number">0</span>;<br>            rightUp[r+c] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">DFS</span>(<span class="hljs-number">1</span>);<br>    cout&lt;&lt;tot;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p><a target="_blank" rel="noopener" href="https://www.dotcpp.com/oj/problem2690.html">蓝桥杯2022年第十三届省赛真题-重新排序 - C语言网 (dotcpp.com)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL; <span class="hljs-comment">//不开long long见祖宗</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1000000</span> + <span class="hljs-number">10</span>;<br>LL Ai[MAXN];       <span class="hljs-comment">//原数组</span><br>LL raSum;          <span class="hljs-comment">//原数组的每次查询的和的总和</span><br>LL range[MAXN];    <span class="hljs-comment">//记录每次查询的范围</span><br>LL queryNum[MAXN]; <span class="hljs-comment">//所有查询范围中元素被查询的总次数（前缀和）</span><br>LL reSum;          <span class="hljs-comment">//重新排序后每次查询的和的总和</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n; <span class="hljs-comment">//元素个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; Ai[i]; <span class="hljs-comment">//原数组的输入</span><br>    &#125;<br>    cin &gt;&gt; m; <span class="hljs-comment">//查询次数</span><br>    <span class="hljs-type">int</span> L_term, R_term;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>    &#123;<br>        cin &gt;&gt; L_term &gt;&gt; R_term;<br>        range[L_term]++;     <span class="hljs-comment">//左边界</span><br>        range[R_term + <span class="hljs-number">1</span>]--; <span class="hljs-comment">//右边界</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        queryNum[i] = queryNum[i - <span class="hljs-number">1</span>] + range[i]; <span class="hljs-comment">//计算每个元素的查询次数</span><br><br>        raSum += Ai[i] * queryNum[i]; <span class="hljs-comment">//计算原数组的每次查询的和的总和</span><br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(Ai + <span class="hljs-number">1</span>, Ai + n + <span class="hljs-number">1</span>, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());             <span class="hljs-comment">//对原数组降序排序</span><br>    <span class="hljs-built_in">sort</span>(queryNum + <span class="hljs-number">1</span>, queryNum + n + <span class="hljs-number">1</span>, <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;()); <span class="hljs-comment">//对所有元素的查询次数进行降序排序</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        reSum += Ai[i] * queryNum[i]; <span class="hljs-comment">//计算重新排序后的每次查询的和的总和</span><br>    &#125;<br><br>    cout &lt;&lt; reSum - raSum &lt;&lt; endl; <span class="hljs-comment">//输出答案</span><br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="Treap-名次树"><a href="#Treap-名次树" class="headerlink" title="Treap 名次树"></a>Treap 名次树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> id[<span class="hljs-number">5000000</span>+<span class="hljs-number">5</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> size;          <span class="hljs-comment">//以这个结点为根的子树的结点总数量，用于名次树</span><br>    <span class="hljs-type">int</span> rank;          <span class="hljs-comment">//优先级</span><br>    <span class="hljs-type">int</span> key;           <span class="hljs-comment">//键值</span><br>    Node *son[<span class="hljs-number">2</span>];     <span class="hljs-comment">//son[0]左儿子, son[1]右儿子</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Node &amp;a)<span class="hljs-type">const</span>&#123;<span class="hljs-keyword">return</span> rank &lt; a.rank;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(x==key) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> x&lt;key?<span class="hljs-number">0</span>:<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>&#123;     <span class="hljs-comment">//更新size</span><br>        size=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(son[<span class="hljs-number">0</span>]!=<span class="hljs-literal">NULL</span>) size+= son[<span class="hljs-number">0</span>]-&gt;size;<br>        <span class="hljs-keyword">if</span>(son[<span class="hljs-number">1</span>]!=<span class="hljs-literal">NULL</span>) size+= son[<span class="hljs-number">1</span>]-&gt;size;<br>        &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(Node* &amp;o,<span class="hljs-type">int</span> d)</span></span>&#123;    <span class="hljs-comment">//d=0左旋转，d=1右旋</span><br>        Node *k=o-&gt;son[d^<span class="hljs-number">1</span>];      <span class="hljs-comment">//d^1与1-d等价，但是更快</span><br>        o-&gt;son[d^<span class="hljs-number">1</span>]=k-&gt;son[d];<br>        k-&gt;son[d]=o;<br>        o-&gt;<span class="hljs-built_in">update</span>();<br>        k-&gt;<span class="hljs-built_in">update</span>();<br>        o=k;<br>    &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Node* &amp;o,<span class="hljs-type">int</span> x)</span></span>&#123;   <span class="hljs-comment">//把x插入到树中</span><br>        <span class="hljs-keyword">if</span>(o==<span class="hljs-literal">NULL</span>)&#123;<br>            o=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>            o-&gt;son[<span class="hljs-number">0</span>]=o-&gt;son[<span class="hljs-number">1</span>]=<span class="hljs-literal">NULL</span>;<br>            o-&gt;rank=<span class="hljs-built_in">rand</span>();<br>            o-&gt;key=x;<br>            o-&gt;size=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> d=o-&gt;<span class="hljs-built_in">cmp</span>(x);<br>            <span class="hljs-built_in">insert</span>(o-&gt;son[d],x);<br>            o-&gt;<span class="hljs-built_in">update</span>();<br>            <span class="hljs-keyword">if</span>(o&lt;o-&gt;son[d])<br>                <span class="hljs-built_in">rotate</span>(o,d^<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(Node* o,<span class="hljs-type">int</span> k)</span></span>&#123;   <span class="hljs-comment">//返回第k大的数</span><br>        <span class="hljs-keyword">if</span>(o==<span class="hljs-literal">NULL</span>||k&lt;=<span class="hljs-number">0</span>||k&gt;o-&gt;size)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> s=o-&gt;son[<span class="hljs-number">1</span>]==<span class="hljs-literal">NULL</span>?<span class="hljs-number">0</span>:o-&gt;son[<span class="hljs-number">1</span>]-&gt;size;<br>        <span class="hljs-keyword">if</span>(k==s+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> o-&gt;key;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k&lt;=s) <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(o-&gt;son[<span class="hljs-number">1</span>],k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">kth</span>(o-&gt;son[<span class="hljs-number">0</span>],k-s<span class="hljs-number">-1</span>);<br>    &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(Node* o,<span class="hljs-type">int</span> k)</span></span>&#123;  <span class="hljs-comment">//返回元素k的名次</span><br>        <span class="hljs-keyword">if</span>(o==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> d=o-&gt;<span class="hljs-built_in">cmp</span>(k);<br>        <span class="hljs-keyword">if</span>(d==<span class="hljs-number">-1</span> )<br>            <span class="hljs-keyword">return</span> o-&gt;son[<span class="hljs-number">1</span>] ==<span class="hljs-literal">NULL</span>? <span class="hljs-number">1</span>: o-&gt;son[<span class="hljs-number">1</span>]-&gt;size+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(o-&gt;son[d],k);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> tmp=<span class="hljs-built_in">find</span>(o-&gt;son[d],k);<br>            <span class="hljs-keyword">if</span>(tmp==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> o-&gt;son[<span class="hljs-number">1</span>] ==<span class="hljs-literal">NULL</span>? tmp+<span class="hljs-number">1</span> : tmp+<span class="hljs-number">1</span>+o-&gt;son[<span class="hljs-number">1</span>]-&gt;size;<br>        &#125;<br>    &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n)&amp;&amp;n)&#123;<br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>        <span class="hljs-type">int</span> k,g;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;k,&amp;g);<br>        Node *root=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>        root-&gt;son[<span class="hljs-number">0</span>]=root-&gt;son[<span class="hljs-number">1</span>]=<span class="hljs-literal">NULL</span>;<br>        root-&gt;rank=<span class="hljs-built_in">rand</span>(); root-&gt;key=g; root-&gt;size=<span class="hljs-number">1</span>;<br>        id[g]=k;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,k,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;k,&amp;g);<br>            id[g]=k;<br>            <span class="hljs-built_in">insert</span>(root,g);<br>            <span class="hljs-type">int</span> t=<span class="hljs-built_in">find</span>(root,g);   <span class="hljs-comment">//返回新和尚的名次</span><br>            <span class="hljs-type">int</span> ans1,ans2,ans;<br>            ans1=<span class="hljs-built_in">kth</span>(root,t<span class="hljs-number">-1</span>);   <span class="hljs-comment">//前一名的老和尚</span><br>            ans2=<span class="hljs-built_in">kth</span>(root,t+<span class="hljs-number">1</span>);   <span class="hljs-comment">//后一名的老和尚</span><br>            <span class="hljs-keyword">if</span>(ans1!=<span class="hljs-number">-1</span>&amp;&amp;ans2!=<span class="hljs-number">-1</span>)<br>                ans= ans1-g &gt;= g-ans2 ? ans2:ans1;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ans1==<span class="hljs-number">-1</span>) ans=ans2;<br>            <span class="hljs-keyword">else</span> ans=ans1;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,k,id[ans]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>线段树可以在log_2n的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作</p>
<h3 id="点修改与点查询"><a href="#点修改与点查询" class="headerlink" title="点修改与点查询"></a>点修改与点查询</h3><p><a target="_blank" rel="noopener" href="http://poj.org/problem?id=2182">2182 – Lost Cows (poj.org)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//poj2182</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">8000</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> pre[MAX];  <span class="hljs-comment">//用于输入原始序列</span><br><span class="hljs-type">int</span> tree[MAX*<span class="hljs-number">4</span>];  <span class="hljs-comment">//长度，即该区间中的牛的个数</span><br><span class="hljs-type">int</span> ans[MAX];  <span class="hljs-comment">//用于储存答案</span><br><br><span class="hljs-comment">//建树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build_tree</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(L==R)<br>    &#123;<br>        tree[node] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (L+R)/<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> left_node = node*<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> right_node = node*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build_tree</span>(left_node,L,mid);<br>    <span class="hljs-built_in">build_tree</span>(right_node,mid+<span class="hljs-number">1</span>,R);<br>    <span class="hljs-comment">//回溯，向上更新</span><br>    tree[node] = tree[left_node] + tree[right_node];<br>&#125;<br><br><span class="hljs-comment">//查询  order为要查找第几大的数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> order, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    tree[node]--;<br>    <span class="hljs-keyword">if</span>(L==R)&#123;<br>        <span class="hljs-keyword">return</span> L;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (L+R)/<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> left_node = node*<span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> right_node = node*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(tree[left_node]&gt;=order)  <span class="hljs-comment">//如果左节点足够，继续递归左节点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(order,left_node,L,mid);<br>    <span class="hljs-keyword">if</span>(tree[left_node]&lt;order)  <span class="hljs-comment">//如果左节点不够，递归右节点（注意要减去左节点的数量）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(order-tree[left_node],right_node,mid+<span class="hljs-number">1</span>,R);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">build_tree</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    pre[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;pre[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)  <span class="hljs-comment">//反向遍历</span><br>    &#123;<br>        ans[i] = <span class="hljs-built_in">query</span>(pre[i]+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<h3 id="区间修改与区间和"><a href="#区间修改与区间和" class="headerlink" title="区间修改与区间和"></a>区间修改与区间和</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//LGP3372</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> LL;  <span class="hljs-comment">//不开 long long 见祖宗</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Max = <span class="hljs-number">100000</span>+<span class="hljs-number">10</span>;<br>LL pre[Max];<br>LL tree[Max*<span class="hljs-number">4</span>];  <span class="hljs-comment">//线段树，用于储存区间和</span><br>LL add[Max*<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//线段树的某个区间需要加上的数</span><br><br><span class="hljs-comment">//建树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build_tree</span><span class="hljs-params">(<span class="hljs-type">int</span> node, LL L, LL R)</span>  <span class="hljs-comment">//L,R即为总长度的两端点</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(L==R)  <span class="hljs-comment">//如果左端点==右端点，即到达最底端，赋值并返回</span><br>    &#123;<br>        tree[node] = pre[L];  <span class="hljs-comment">//赋初值</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    LL mid = (L + R) / <span class="hljs-number">2</span>;  <span class="hljs-comment">//划分中线</span><br>    LL left_node = <span class="hljs-number">2</span>*node;  <span class="hljs-comment">//当前节点的左节点</span><br>    LL right_node = <span class="hljs-number">2</span>*node + <span class="hljs-number">1</span>;  <span class="hljs-comment">//当前节点的右节点</span><br>    <span class="hljs-built_in">build_tree</span>(left_node,L,mid);  <span class="hljs-comment">//向左递归建树</span><br>    <span class="hljs-built_in">build_tree</span>(right_node,mid+<span class="hljs-number">1</span>,R);  <span class="hljs-comment">//向右递归建树</span><br>    tree[node] = tree[left_node] + tree[right_node];  <span class="hljs-comment">//回溯，向上更新</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(<span class="hljs-type">int</span> node, LL L, LL R)</span>  <span class="hljs-comment">//向下更新</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(add[node])  <span class="hljs-comment">//如果当前节点还有需要加的数没有下放，就下放</span><br>    &#123;<br>        LL mid = (L + R) / <span class="hljs-number">2</span>;  <span class="hljs-comment">//划分中线</span><br>        LL left_node = <span class="hljs-number">2</span>*node;  <span class="hljs-comment">//当前节点的左节点</span><br>        LL right_node = <span class="hljs-number">2</span>*node+<span class="hljs-number">1</span>;  <span class="hljs-comment">//当前节点的右节点</span><br>        add[left_node] += add[node];  <span class="hljs-comment">//左节点加数更新</span><br>        add[right_node] += add[node];  <span class="hljs-comment">//右节点加数更新</span><br>        tree[left_node] += (mid - L + <span class="hljs-number">1</span>)*add[node];  <span class="hljs-comment">//左节点更新</span><br>        tree[right_node] += (R - (mid+<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>)*add[node];  <span class="hljs-comment">//右节点更新</span><br>        add[node] = <span class="hljs-number">0</span>;  <span class="hljs-comment">//已经向下传递，清空本节点的加数</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_tree</span><span class="hljs-params">(LL _start, LL _end, LL val ,<span class="hljs-type">int</span> node, LL L, LL R)</span>  <span class="hljs-comment">//更新操作</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(_start&lt;=L &amp;&amp; _end&gt;=R)  <span class="hljs-comment">//如果递归到一个包含于 要求修改的区间 的区间，修改并返回</span><br>    &#123;<br>        tree[node] += (R-L+<span class="hljs-number">1</span>)*val;<br>        add[node] += val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">push_down</span>(node,L,R);  <span class="hljs-comment">//向下更新，把add[node]下放，更新左右节点以及左右节点的add</span><br>    LL mid = (L + R) / <span class="hljs-number">2</span>;<br>    LL left_node = <span class="hljs-number">2</span>*node;<br>    LL right_node = <span class="hljs-number">2</span>*node + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(_start&lt;=mid) <span class="hljs-comment">//如果还能分出左边，递归左边</span><br>        <span class="hljs-built_in">update_tree</span>(_start,_end,val,left_node,L,mid);<br>    <span class="hljs-keyword">if</span>(_end&gt;mid) <span class="hljs-comment">//如果还能分出右边，递归右边</span><br>        <span class="hljs-built_in">update_tree</span>(_start,_end,val,right_node,mid+<span class="hljs-number">1</span>,R);<br>    tree[node] = tree[left_node] + tree[right_node];  <span class="hljs-comment">//向上更新，（加上val值）</span><br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">query</span><span class="hljs-params">(LL _start, LL _end, <span class="hljs-type">int</span> node, LL L, LL R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(_start&lt;=L &amp;&amp; _end&gt;=R)  <span class="hljs-comment">//如果递归到一个包含于 要求查询的区间 的区间，直接返回</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> tree[node];<br>    &#125;<br>	<span class="hljs-built_in">push_down</span>(node,L,R);  <span class="hljs-comment">//向下更新，下放</span><br>    LL mid = (L + R) / <span class="hljs-number">2</span>;<br>    LL left_node = <span class="hljs-number">2</span>*node;<br>    LL right_node = <span class="hljs-number">2</span>*node + <span class="hljs-number">1</span>;<br>    LL ans = <span class="hljs-number">0</span>;  <span class="hljs-comment">//用于区间和的累加</span><br>    <span class="hljs-keyword">if</span>(_start&lt;=mid) <span class="hljs-comment">//如果还能分出左边，递归左边</span><br>        ans += <span class="hljs-built_in">query</span>(_start,_end,left_node,L,mid);<br>    <span class="hljs-keyword">if</span>(_end&gt;mid) <span class="hljs-comment">//如果还能分出右边，递归右边</span><br>        ans += <span class="hljs-built_in">query</span>(_start,_end,right_node,mid+<span class="hljs-number">1</span>,R);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LL n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;pre[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">build_tree</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> q;<br>        <span class="hljs-type">int</span> x,y;<br>        LL k;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;q);<br>        <span class="hljs-keyword">if</span>(q==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%lld&quot;</span>,&amp;x,&amp;y,&amp;k);<br>            <span class="hljs-built_in">update_tree</span>(x,y,k,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q==<span class="hljs-number">2</span>)<br>        &#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>            LL ans = <span class="hljs-built_in">query</span>(x,y,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="区间最大值与最小值的差"><a href="#区间最大值与最小值的差" class="headerlink" title="区间最大值与最小值的差"></a>区间最大值与最小值的差</h3><p>[P2880 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2880">USACO07JAN] Balanced Lineup G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//LGP2880</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> LL;<br><span class="hljs-type">const</span> LL MAX = <span class="hljs-number">5</span>*<span class="hljs-number">10000</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> height[MAX];  <span class="hljs-comment">//用于输入原序列</span><br><span class="hljs-type">int</span> tree_max[MAX*<span class="hljs-number">4</span>];  <span class="hljs-comment">//记录最大值</span><br><span class="hljs-type">int</span> tree_min[MAX*<span class="hljs-number">4</span>];  <span class="hljs-comment">//记录最小值</span><br><br><span class="hljs-comment">//建树，</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build_tree</span><span class="hljs-params">(<span class="hljs-type">int</span> node,LL L,LL R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(L==R)  <span class="hljs-comment">//如果左右端点相等，即到达底部，赋值并返回</span><br>    &#123;<br>        tree_max[node] = height[L];<br>        tree_min[node] = height[L];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    LL mid = (L+R)/<span class="hljs-number">2</span>;<br>    LL left_node = node*<span class="hljs-number">2</span>;<br>    LL right_node = node*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build_tree</span>(left_node,L,mid);<br>    <span class="hljs-built_in">build_tree</span>(right_node,mid+<span class="hljs-number">1</span>,R);<br>    <span class="hljs-comment">//回溯，向上更新，更新区间的最大值和最小值</span><br>    tree_max[node] = <span class="hljs-built_in">max</span>(tree_max[left_node],tree_max[right_node]);<br>    tree_min[node] = <span class="hljs-built_in">min</span>(tree_min[left_node],tree_min[right_node]);<br>&#125;<br><br><span class="hljs-comment">//由于要返回最大值和最小值，故直接用引用的方式传入参数Max和Min</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">query</span><span class="hljs-params">(LL _start,LL _end,<span class="hljs-type">int</span> node,LL L, LL R,<span class="hljs-type">int</span> &amp;Max,<span class="hljs-type">int</span> &amp;Min)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(_start&lt;=L &amp;&amp; _end&gt;=R)  <span class="hljs-comment">//如果递归到一个包含于 询问区间 的区间，返回最大值和最小值</span><br>    &#123;<br>        Max = <span class="hljs-built_in">max</span>(Max,tree_max[node]);<br>        Min = <span class="hljs-built_in">min</span>(Min,tree_min[node]);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    LL mid = (L+R)/<span class="hljs-number">2</span>;<br>    LL left_node = node*<span class="hljs-number">2</span>;<br>    LL right_node = node*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(_start&lt;=mid) <span class="hljs-built_in">query</span>(_start,_end,left_node,L,mid,Max,Min);<br>    <span class="hljs-keyword">if</span>(_end&gt;mid) <span class="hljs-built_in">query</span>(_start,_end,right_node,mid+<span class="hljs-number">1</span>,R,Max,Min);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,q;<br>    cin&gt;&gt;n&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;height[i]);<br>    &#125;<br>    <span class="hljs-built_in">build_tree</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>    <span class="hljs-type">int</span> a,b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-type">int</span> Max = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> Min = INT_MAX;<br>        <span class="hljs-built_in">query</span>(a,b,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n,Max,Min);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,Max-Min);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>







<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><h3 id="点修改与点查询-1"><a href="#点修改与点查询-1" class="headerlink" title="点修改与点查询"></a>点修改与点查询</h3><p><a target="_blank" rel="noopener" href="http://poj.org/problem?id=2182">2182 – Lost Cows (poj.org)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) ((x)&amp;-(x))</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX = <span class="hljs-number">10000</span>;<br><span class="hljs-type">int</span> tree[MAX];<br><span class="hljs-type">int</span> pre[MAX];<br><span class="hljs-type">int</span> ans[MAX];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=n)<br>    &#123;<br>        tree[x] += d;<br>        x += <span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">0</span>)<br>    &#123;<br>        sum += tree[x];<br>        x -= <span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findpos</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(L&lt;R)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = (L+R)/<span class="hljs-number">2</span>;  <span class="hljs-comment">//得到的是该节点的左子树的下标</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sum</span>(mid)&lt;x)<br>            L = mid+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            R = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> L;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    pre[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;pre[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        tree[i] = <span class="hljs-built_in">lowbit</span>(i);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-built_in">findpos</span>(pre[i]+<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>        <span class="hljs-built_in">add</span>(x,<span class="hljs-number">-1</span>);<br>        ans[i] = x;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="区间最大值和最小值的差"><a href="#区间最大值和最小值的差" class="headerlink" title="区间最大值和最小值的差"></a>区间最大值和最小值的差</h3><p>[P2880 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2880">USACO07JAN] Balanced Lineup G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//LGP2880</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,q;<br><span class="hljs-type">int</span> height[<span class="hljs-number">5</span>*<span class="hljs-number">10000</span>+<span class="hljs-number">5</span>];  <span class="hljs-comment">//存原始数组</span><br><span class="hljs-type">int</span> tree_max[<span class="hljs-number">5</span>*<span class="hljs-number">10000</span>+<span class="hljs-number">5</span>];  <span class="hljs-comment">//存最大值</span><br><span class="hljs-type">int</span> tree_min[<span class="hljs-number">5</span>*<span class="hljs-number">10000</span>+<span class="hljs-number">5</span>];  <span class="hljs-comment">//存最小值</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) ((x)&amp;-(x))  <span class="hljs-comment">//树状数组核心操作lowbit</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> d)</span>  <span class="hljs-comment">//更新（向上）</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(x&lt;=n)<br>    &#123;<br>        tree_max[x] = <span class="hljs-built_in">max</span>(tree_max[x],d);<br>        tree_min[x] = <span class="hljs-built_in">min</span>(tree_min[x],d);<br>        x += <span class="hljs-built_in">lowbit</span>(x);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> L,<span class="hljs-type">int</span> R)</span>  <span class="hljs-comment">//查询（向下）</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> Max = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> Min = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span>(L&lt;=R)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(R-<span class="hljs-built_in">lowbit</span>(R)&gt;=L)<br>        &#123;<br>            Max = <span class="hljs-built_in">max</span>(Max,tree_max[R]);<br>            Min = <span class="hljs-built_in">min</span>(Min,tree_min[R]);<br>            R -= <span class="hljs-built_in">lowbit</span>(R);<br>        &#125;<br>        Max = <span class="hljs-built_in">max</span>(height[R],Max);<br>        Min = <span class="hljs-built_in">min</span>(height[R],Min);<br>        R--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Max - Min;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(tree_min,<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>,<span class="hljs-built_in">sizeof</span>(tree_min));  <span class="hljs-comment">//初始化</span><br>    cin&gt;&gt;n&gt;&gt;q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;height[i]);<br>        <span class="hljs-built_in">update</span>(i,height[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=q;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> L,R;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;L,&amp;R);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-built_in">query</span>(L,R));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>









<h2 id="动态规划-DP"><a href="#动态规划-DP" class="headerlink" title="动态规划 DP"></a>动态规划 DP</h2><h3 id="0-x2F-1背包"><a href="#0-x2F-1背包" class="headerlink" title="0&#x2F;1背包"></a>0&#x2F;1背包</h3><p>（1）二维数组形式：</p>
<p>[P1048 <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1048">NOIP2005 普及组] 采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Herb</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-type">int</span> time;<br>&#125;herb[<span class="hljs-number">110</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">110</span>][<span class="hljs-number">1010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ans</span><span class="hljs-params">()</span>  <span class="hljs-comment">//DP - 0/1背包的核心</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=t;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(herb[i].time&gt;j)<br>            &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i<span class="hljs-number">-1</span>][j-herb[i].time]+herb[i].val);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][t];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;t&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;herb[i].time,&amp;herb[i].val);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">ans</span>());<br>&#125;<br></code></pre></td></tr></table></figure>



<p>（2）滚动数组形式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> t,m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Herb</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-type">int</span> time;<br>&#125;herb[<span class="hljs-number">110</span>];<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ans</span><span class="hljs-params">()</span>  <span class="hljs-comment">//DP - 0/1背包的核心</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=t;j&gt;=herb[i].time;j--)  <span class="hljs-comment">//倒过来</span><br>        &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-herb[i].time] + herb[i].val);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[t];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;t&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;herb[i].time,&amp;herb[i].val);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">ans</span>());<br>&#125;<br></code></pre></td></tr></table></figure>



<p>01背包变式</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1802">P1802 5 倍经验日 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>LL N, X;<br>LL x[<span class="hljs-number">1010</span>];<br>LL win[<span class="hljs-number">1010</span>];<br>LL lose[<span class="hljs-number">1010</span>];<br>LL dp[<span class="hljs-number">1010</span>];<br><br><span class="hljs-function">LL <span class="hljs-title">dp_func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (LL i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (LL j = X; j &gt;= x[i]; j--)  <span class="hljs-comment">//有足够药品，则比较 用药打赢好 还是 不用药打输好</span><br>        &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j] + lose[i], dp[j - x[i]] + win[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (LL j = x[i] - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--)  <span class="hljs-comment">//药品不足，直接认输</span><br>        &#123;<br>            dp[j] += lose[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[X];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; N &gt;&gt; X;<br>    <span class="hljs-keyword">for</span> (LL i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>    &#123;<br>        cin &gt;&gt; lose[i] &gt;&gt; win[i] &gt;&gt; x[i];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-number">5</span> * <span class="hljs-built_in">dp_func</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1616">P1616 疯狂的采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long int</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Herb</span><br>&#123;<br>    ll time;<br>    ll value;<br>&#125; herb[<span class="hljs-number">10010</span>];<br><br>ll T,M;<br>ll dp[<span class="hljs-number">10000010</span>];<br><br><span class="hljs-function">ll <span class="hljs-title">ans</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=M;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=herb[i].time;j&lt;=T;j++)&#123;<br>                dp[j] = <span class="hljs-built_in">max</span>(dp[j],dp[j-herb[i].time]+herb[i].value);  <span class="hljs-comment">//滚动数组</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[T];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;T&gt;&gt;M;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=M;i++)<br>    &#123;<br>        cin&gt;&gt;herb[i].time&gt;&gt;herb[i].value;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-built_in">ans</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="LCS-最长公共子序列"><a href="#LCS-最长公共子序列" class="headerlink" title="LCS 最长公共子序列"></a>LCS 最长公共子序列</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1439">P1439 【模板】最长公共子序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列 - 力扣（LeetCode）</a></p>
<p>未优化版本  </p>
<p>使用二维数组，遇到数据量稍大就会爆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">1010</span>][<span class="hljs-number">1010</span>];<br>string num1[<span class="hljs-number">1010</span>], num2[<span class="hljs-number">1010</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCS</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (num1[i] == num2[j])<br>            &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; num1[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cin &gt;&gt; num2[i];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">LCS</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="LIS-最长递增子序列"><a href="#LIS-最长递增子序列" class="headerlink" title="LIS 最长递增子序列"></a>LIS 最长递增子序列</h3><p>待补充…</p>
<h3 id="递推与记忆化搜索"><a href="#递推与记忆化搜索" class="headerlink" title="递推与记忆化搜索"></a>递推与记忆化搜索</h3><p><a target="_blank" rel="noopener" href="http://poj.org/problem?id=1163">1163 – The Triangle (poj.org)</a>  数塔</p>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h3><p>基本规则<br>模运算的基本规则与四则运算基本一致：</p>
<p>(a + b) % p &#x3D; (a % p + b % p) % p</p>
<p>(a – b) % p &#x3D; (a % p – b % p) % p</p>
<p>(a * b) % p &#x3D; (a % p * b % p) % p</p>
<p>(a^b) % p &#x3D; ((a % p)^b) % p</p>
<p>(a &#x2F; b) % p &#x3D; (a * k) % p  ，其中k是b的逆元。</p>
<h4 id="Problem-取模"><a href="#Problem-取模" class="headerlink" title="Problem  取模"></a>Problem  取模</h4><p>记起始整型变量 x&#x3D;0 ，你需要实现 x与若干个整数的四则运算，每次结果重新保存为 x ，并将最终结果对 p 取模 (不保证 p是质数) 。</p>
<p>输入</p>
<p>首先输入一行两个整数 t,p(1&lt;&#x3D;t&lt;&#x3D;10^5, 2&lt;&#x3D;p&lt;&#x3D;10^9+7) 。</p>
<p>接下来输入 t 行，每行两个整数 c, y (1&lt;&#x3D;c&lt;&#x3D;4,0&lt;&#x3D;|y|&lt;&#x3D;10^18) 。</p>
<p>若 c&#x3D;1 ，计算 x+y 并将结果保存在 x 内。</p>
<p>若 c&#x3D;2，计算 x-y 并将结果保存在 x 内。</p>
<p>若 c&#x3D;3 ，计算 x*y 并将结果保存在 x 内。</p>
<p>若 c&#x3D;4，计算 x&#x2F;y 并将结果保存在 x 内。</p>
<p>输入保证计算过程不会出现零除，且保证除数存在逆元。</p>
<p>输出</p>
<p>每次运算结束后输出一行一个整数，为 x mod p。共输出 t 行，你需要保证输出为非负数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>LL t, p;<br>vector&lt;LL&gt; c;<br>vector&lt;LL&gt; y;<br>LL x = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extend_gcd</span><span class="hljs-params">(LL a, LL b, LL &amp;x, LL &amp;y)</span>  <span class="hljs-comment">//扩展欧几里得</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>    &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">extend_gcd</span>(b, a % b, x, y);<br>    LL tmp = x;<br>    x = y;<br>    y = tmp - (a / b) * y;<br>&#125;<br><br><span class="hljs-function">LL <span class="hljs-title">mod_inverse</span><span class="hljs-params">(LL a, LL m)</span>  <span class="hljs-comment">//求逆元</span></span><br><span class="hljs-function"></span>&#123;<br>    LL x, y;<br>    <span class="hljs-built_in">extend_gcd</span>(a, m, x, y);<br>    <span class="hljs-keyword">return</span> (m + x % m) % m;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; t &gt;&gt; p;<br>    LL cin_temp1, cin_temp2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%lld&quot;</span>, &amp;cin_temp1, &amp;cin_temp2);<br>        c.<span class="hljs-built_in">push_back</span>(cin_temp1);<br>        y.<span class="hljs-built_in">push_back</span>(cin_temp2);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++)<br>    &#123;<br>        y[i] = (y[i] % p + p) % p; <span class="hljs-comment">//确保y[i]&gt;0</span><br>        <span class="hljs-keyword">if</span> (c[i] == <span class="hljs-number">1</span>)<br>        &#123;<br>            x = ((x % p) + (y[i] % p)) % p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[i] == <span class="hljs-number">2</span>)<br>        &#123;<br>            x = ((x % p) - (y[i] % p)) % p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[i] == <span class="hljs-number">3</span>)<br>        &#123;<br>            x = ((x % p) * (y[i] % p)) % p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c[i] == <span class="hljs-number">4</span>)<br>        &#123;<br>            LL k = <span class="hljs-built_in">mod_inverse</span>(y[i], p);<br>            x = ((x % p) * (k % p)) % p;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)<br>            x = (x % p + p) % p; <span class="hljs-comment">//确保x&gt;0</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="快速幂（取模）"><a href="#快速幂（取模）" class="headerlink" title="快速幂（取模）"></a>快速幂（取模）</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1226">P1226 【模板】快速幂||取余运算 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>LL mod;<br><br><span class="hljs-function">LL <span class="hljs-title">fastPow</span><span class="hljs-params">(LL a, LL n)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL base = a;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>)<br>        &#123;<br>            res *= base;<br>            res %= mod;  <span class="hljs-comment">//求余</span><br>        &#125;<br>        base *= base;<br>        base %= mod;  <span class="hljs-comment">//求余</span><br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LL a, n;<br>    cin &gt;&gt; a &gt;&gt; n &gt;&gt; mod;<br>    LL ans = <span class="hljs-built_in">fastPow</span>(a, n);<br>    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;^&quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; mod &quot;</span> &lt;&lt; mod &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>注意：若不需要求余，直接把“求余”的那两行删去即可。</p>
<h3 id="最大公约数GCD"><a href="#最大公约数GCD" class="headerlink" title="最大公约数GCD"></a>最大公约数GCD</h3><h3 id="最小公倍数LCM"><a href="#最小公倍数LCM" class="headerlink" title="最小公倍数LCM"></a>最小公倍数LCM</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-comment">//最大公约数gcd</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-comment">//最小公倍数lcm</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a / <span class="hljs-built_in">gcd</span>(a, b) * b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    cout &lt;&lt; <span class="hljs-built_in">gcd</span>(a, b) &lt;&lt; endl;<br>    <span class="hljs-comment">//也可直接使用&lt;algorithm&gt;头文件里的 __gdc(a,b)函数</span><br>    <span class="hljs-comment">// cout &lt;&lt; __gcd(a, b) &lt;&lt; endl;</span><br>    cout &lt;&lt; <span class="hljs-built_in">lcm</span>(a, b) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extend_gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>    &#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">extend_gcd</span>(b, a % b, x, y);<br>    <span class="hljs-type">int</span> tmp = x;<br>    x = y;<br>    y = tmp - (a / b) * y;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">extend_gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span>  <span class="hljs-comment">//扩展欧几里得</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>)<br>    &#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">extend_gcd</span>(b, a % b, x, y);<br>    <span class="hljs-type">int</span> tmp = x;<br>    x = y;<br>    y = tmp - (a / b) * y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mod_inverse</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> m)</span>  <span class="hljs-comment">//求逆元</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-built_in">extend_gcd</span>(a, m, x, y);<br>    <span class="hljs-keyword">return</span> (m + x % m) % m;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, m;<br>    cin &gt;&gt; a &gt;&gt; m;<br>    cout &lt;&lt; <span class="hljs-built_in">mod_inverse</span>(a, m) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="除法取模"><a href="#除法取模" class="headerlink" title="除法取模"></a>除法取模</h3><p>（a&#x2F;b）mod m &#x3D; (a*k)mod m  ，其中k是b的逆元。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/v_july_v/article/details/7041827">从头到尾彻底理解KMP</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21923021">如何理解next数组的求解</a></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​		Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。</p>
<p>​		下面先直接给出KMP的算法流程（如果感到一点点不适，没关系，坚持下，稍后会有具体步骤及解释，越往后看越会柳暗花明☺）：</p>
<p>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置</p>
<ul>
<li>如果j &#x3D; -1，或者当前字符匹配成功（即S[i] &#x3D;&#x3D; P[j]），都令i++，j++，继续匹配下一个字符；</li>
<li>如果j !&#x3D; -1，且当前字符匹配失败（即S[i] !&#x3D; P[j]），则令 i 不变，j &#x3D; next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。</li>
<li>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文的3.3.3节中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。</li>
</ul>
<p>​		很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] &#x3D; k，代表j 之前的字符串中有最大长度为k 的相同前缀后缀。</p>
<p>​		此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] &#x3D; k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。</p>
<p>转换成代码表示，则是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KmpSearch</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, <span class="hljs-type">char</span>* p)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> sLen = <span class="hljs-built_in">strlen</span>(s);<br>	<span class="hljs-type">int</span> pLen = <span class="hljs-built_in">strlen</span>(p);<br>	<span class="hljs-keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)<br>	&#123;<br>		<span class="hljs-comment">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    </span><br>		<span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s[i] == p[j])<br>		&#123;<br>			i++;<br>			j++;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>		&#123;<br>			<span class="hljs-comment">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span><br>			<span class="hljs-comment">//next[j]即为j所对应的next值      </span><br>			j = next[j];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (j == pLen)<br>		<span class="hljs-keyword">return</span> i - j;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​		继续拿之前的例子来说，当S[10]跟P[6]匹配失败时，KMP不是跟暴力匹配那样简单的把模式串右移一位，而是执行第②条指令：“如果j !&#x3D; -1，且当前字符匹配失败（即S[i] !&#x3D; P[j]），则令 i 不变，j &#x3D; next[j]”，即j 从6变到2（后面我们将求得P[6]，即字符D对应的next 值为2），所以相当于模式串向右移动的位数为j - next[j]（j - next[j] &#x3D; 6-2 &#x3D; 4）。</p>
 <img src="image-20220930093303598.png" srcset="/img/loading.gif" lazyload alt="image-20220930093303598" style="zoom:50%;" />

<p>​		向右移动4位后，S[10]跟P[2]继续匹配。为什么要向右移动4位呢，因为移动4位后，模式串中又有个“AB”可以继续跟S[8]S[9]对应着，从而不用让i 回溯。相当于在除去字符D的模式串子串中寻找相同的前缀和后缀，然后根据前缀后缀求出next 数组，最后基于next 数组进行匹配（不关心next 数组是怎么求来的，只想看匹配过程是咋样的，可直接跳到下文3.3.4节）。</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul>
<li><p>1）寻找前缀后缀最长公共元素长度</p>
<ul>
<li><p>对于 P &#x3D; p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk &#x3D; pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。举个例子，如果给定的模式串为 <strong>“abab”</strong>，那么它的各个子串的前缀后缀的公共元素的最大长度如下表格所示：</p>
 <img src="image-20220930093457079.png" srcset="/img/loading.gif" lazyload alt="image-20220930093457079" style="zoom: 67%;" />

<blockquote>
<p>比如对于字符串aba来说，它有长度为1的相同前缀后缀a；而对于字符串abab来说，它有长度为2的相同前缀后缀ab（相同前缀后缀的长度为k + 1，k + 1 &#x3D; 2）。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>2）求next数组</p>
<ul>
<li><p>next 数组考虑的是除当前字符外的最长相同前缀后缀，所以通过第①步骤求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将第①步骤中求得的值整体右移一位，然后初值赋为-1，如下表格所示：</p>
 <img src="image-20220930093601245.png" srcset="/img/loading.gif" lazyload alt="image-20220930093601245" style="zoom:67%;" />

<blockquote>
<p>比如对于aba来说，第3个字符a之前的字符串ab中有长度为0的相同前缀后缀，所以第3个字符a对应的next值为0；而对于abab来说，第4个字符b之前的字符串aba中有长度为1的相同前缀后缀a，所以第4个字符b对应的next值为1（相同前缀后缀的长度为k，k &#x3D; 1）。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>3）根据next数组进行匹配</p>
<ul>
<li><p>匹配失配，j &#x3D; next [j]，模式串向右移动的位数为：j - next[j]。换言之，当模式串的后缀pj-k pj-k+1, …, pj-1 跟文本串si-k si-k+1, …, si-1匹配成功，但pj 跟si匹配失败时，因为next[j] &#x3D; k，相当于在不包含pj的模式串中有最大长度为k 的相同前缀后缀，即p0 p1 …pk-1 &#x3D; pj-k pj-k+1…pj-1，故令j &#x3D; next[j]，从而让模式串右移j - next[j] 位，使得模式串的前缀p0 p1, …, pk-1对应着文本串 si-k si-k+1, …, si-1，而后让pk 跟si 继续匹配。如下图所示：</p>
 <img src="image-20220930093807355.png" srcset="/img/loading.gif" lazyload alt="image-20220930093807355" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<p>​		综上，KMP的next 数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。如模式串中在j 处的字符跟文本串在i 处的字符匹配失配时，下一步用next [j] 处的字符继续跟文本串i 处的字符匹配，相当于模式串向右移动 j - next[j] 位。</p>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><h5 id="1-寻找最长前缀后缀"><a href="#1-寻找最长前缀后缀" class="headerlink" title="1. 寻找最长前缀后缀"></a>1. 寻找最长前缀后缀</h5><p>如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示：</p>
<p> <img src="/2021/11/25/AlgorithmNote/20140725231726921" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（<strong>下简称《最大长度表》</strong>）：</p>
<p> <img src="/2021/11/25/AlgorithmNote/20140721222801918" srcset="/img/loading.gif" lazyload alt="img"></p>
<h5 id="2-基于《最大长度表》匹配"><a href="#2-基于《最大长度表》匹配" class="headerlink" title="2. 基于《最大长度表》匹配"></a>2. 基于《最大长度表》匹配</h5><p>因为模式串中首尾可能会有重复的字符，故可得出下述结论：</p>
<blockquote>
<p>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</p>
</blockquote>
<p>下面，咱们就结合之前的《最大长度表》和上述结论，进行字符串的匹配。如果给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示：</p>
 <img src="20140723224710203" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />

<ol>
<li><p>因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可，直到模式串中的字符A跟文本串的第5个字符A匹配成功：</p>
 <img src="20140726213602848" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />
</li>
<li><p>继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已经匹配的字符数为6个（ABCDAB），然后根据《最大长度表》可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论，可知需要向右移动6 - 2 &#x3D; 4 位。</p>
 <img src="20140721223809617" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />
</li>
<li><p>模式串向右移动4位后，发现C处再度失配，因为此时已经匹配了2个字符（AB），且上一位字符B对应的最大长度值为0，所以向右移动：2 - 0 &#x3D;2 位。</p>
 <img src="20140721223539765" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />
</li>
<li><p>A与空格失配，向右移动1 位。</p>
 <img src="20140721223823548" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />
</li>
<li><p>继续比较，发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B对应的最大长度2，即向右移动6 - 2 &#x3D; 4 位。</p>
 <img src="20140721223558140" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />
</li>
<li><p>经历第5步后，发现匹配成功，过程结束。</p>
 <img src="20140721223611515" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" /></li>
</ol>
<p>​		通过上述匹配过程可以看出，问题的关键就是寻找模式串中最大长度的相同前缀和后缀，找到了模式串中每个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。而这个最大长度便正是next 数组要表达的含义。</p>
<h5 id="3-根据《最大长度表》求next-数组"><a href="#3-根据《最大长度表》求next-数组" class="headerlink" title="3. 根据《最大长度表》求next 数组"></a>3. 根据《最大长度表》求next 数组</h5><p>由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为：</p>
 <img src="20140721230517324" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 80%;" />

<p>而且，根据这个表可以得出下述结论</p>
<blockquote>
<p>失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值</p>
</blockquote>
<p>​		上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。</p>
<p>​		给定字符串“ABCDABD”，可求得它的next 数组如下：</p>
<p>​		 <img src="20140721230250468" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 80%;" /></p>
<p>​		把next 数组跟之前求得的最大长度表对比后，不难发现，next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。</p>
<p>​		换言之，对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下：</p>
<p>​		 <img src="20140728110939595" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;" /></p>
<p>​		根据最大长度表求出了next 数组后，从而有</p>
<blockquote>
<p>​		失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值</p>
</blockquote>
<p>而后，你会发现，无论是基于《最大长度表》的匹配，还是基于next 数组的匹配，两者得出来的向右移动的位数是一样的。为什么呢？因为：</p>
<ul>
<li>根据《最大长度表》，失配时，模式串向右移动的位数 &#x3D; 已经匹配的字符数 - 失配字符的上一位字符的最大长度值</li>
<li>而根据《next 数组》，失配时，模式串向右移动的位数 &#x3D; 失配字符的位置 - 失配字符对应的next 值<br>其中，从0开始计数时，失配字符的位置 &#x3D; 已经匹配的字符数（失配字符不计数），而失配字符对应的next 值 &#x3D; 失配字符的上一位字符的最大长度值，两相比较，结果必然完全一致。</li>
</ul>
<p>所以，你可以把《最大长度表》看做是next 数组的雏形，甚至就把它当做next 数组也是可以的，区别不过是怎么用的问题。</p>
<h5 id="通过代码递推计算next-数组"><a href="#通过代码递推计算next-数组" class="headerlink" title="通过代码递推计算next 数组*"></a>通过代码递推计算next 数组*</h5><p>基于之前的理解，可知计算next 数组的方法可以采用递推：</p>
<ul>
<li><p>如果对于值k，已有p0 p1, …, pk-1 &#x3D; pj-k pj-k+1, …, pj-1，相当于next[j] &#x3D; k。</p>
<ul>
<li><p>此意味着什么呢？究其本质，next[j] &#x3D; k 代表p[j] 之前的模式串子串中，有长度为k 的相同前缀和后缀。有了这个next 数组，在KMP匹配中，当模式串中j 处的字符失配时，下一步用next[j]处的字符继续跟文本串匹配，相当于模式串向右移动j - next[j] 位。</p>
<blockquote>
<p>举个例子，如下图，根据模式串 “ABCDABD” 的next 数组可知失配位置的字符D对应的next 值为2，代表字符D前有长度为2的相同前缀和后缀（这个相同的前缀后缀即为“AB”），失配后，模式串需要向右移动j - next [j] &#x3D; 6 - 2 &#x3D;4位。</p>
 <img src="20140721223809617-1664502783904" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;" />

<p>向右移动4位后，模式串中的字符C继续跟文本串匹配。</p>
 <img src="20140721223539765-1664502831947" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;" /></blockquote>
</li>
</ul>
</li>
<li><p>下面的问题是：已知next [0, …, j]，如何求出next [j + 1]呢？</p>
</li>
<li><p>对于P的前j+1个序列字符：</p>
<ul>
<li><p>若p[k] &#x3D;&#x3D; p[j]，则next[j + 1 ] &#x3D; next [j] + 1 &#x3D; k + 1；</p>
</li>
<li><p>若p[k ] ≠ p[j]，如果此时p[ next[k] ] &#x3D;&#x3D; p[j ]，则next[ j + 1 ] &#x3D;  next[k] + 1，否则继续递归前缀索引k &#x3D; next[k]，而后重复此过程。 相当于在字符p[j+1]之前不存在长度为k+1的前缀”p0 p1, …, pk-1 pk”跟后缀“pj-k pj-k+1, …, pj-1 pj”相等，那么是否可能存在另一个值t+1 &lt; k+1，使得长度更小的前缀 “p0 p1, …, pt-1 pt” 等于长度更小的后缀 “pj-t pj-t+1, …, pj-1 pj” 呢？如果存在，那么这个t+1 便是next[ j+1]的值，此相当于利用已经求得的next 数组（next [0, …, k, …, j]）进行P串前缀跟P串后缀的匹配。</p>
</li>
<li><p>如下图所示，假定给定模式串ABCDABCE，且已知next [j] &#x3D; k（相当于“p0 pk-1” &#x3D; “pj-k pj-1” &#x3D; AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk &#x3D; pj &#x3D; C，所以next[j + 1] &#x3D; next[j] + 1 &#x3D; k + 1（可以看出next[j + 1] &#x3D; 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。</p>
 <img src="20140729182154066" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;" />
</li>
<li><p>但如果pk !&#x3D; pj 呢？说明“p0 pk-1 pk”  ≠ “pj-k pj-1 pj”。换言之，当pk !&#x3D; pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以 ABC 跟 ABD 不相同，即字符E前的模式串没有长度为 k+1 的相同前缀后缀，也就不能再简单的令：next[j + 1] &#x3D; next[j] + 1 。所以，咱们只能去寻找长度更短一点的相同前缀后缀。</p>
 <img src="20140729181940812" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;" />

<p>​		结合上图来讲，若能在前缀“ p0 pk-1 pk ” 中不断的递归前缀索引k &#x3D; next [k]，找到一个字符pk’ 也为D，代表pk’ &#x3D; pj，且满足p0 pk’-1 pk’ &#x3D; pj-k’ pj-1 pj，则最大相同的前缀后缀长度为k’ + 1，从而next [j + 1] &#x3D; k’ + 1 &#x3D; next [k’ ] + 1。否则前缀中没有D，则代表没有相同的前缀后缀，next [j + 1] &#x3D; 0。</p>
<p>​		那为何递归前缀索引k &#x3D; next[k]，就能找到长度更短的相同前缀后缀呢？这又归根到next数组的含义。我们拿前缀 p0 pk-1 pk 去跟后缀pj-k pj-1 pj匹配，如果pk 跟pj 失配，下一步就是用p[next[k]] 去跟pj 继续匹配，如果p[ next[k] ]跟pj还是不匹配，则需要寻找长度更短的相同前缀后缀，即下一步用p[ next[ next[k] ] ]去跟pj匹配。此过程相当于模式串的自我匹配，所以不断的递归k &#x3D; next[k]，直到要么找到长度更短的相同前缀后缀，要么没有长度更短的相同前缀后缀。如下图所示：</p>
 <img src="20150812214857858" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 50%;" />

<p><strong>个人理解：</strong>前面已经匹配上的前后缀是相同的，因此只需要在前缀里找到相应的公共前后缀即可</p>
<p>详细理解可见 “快速求next数组”</p>
</li>
<li><p>所以，因最终在前缀ABC中没有找到D，故E的next 值为0：</p>
</li>
</ul>
</li>
</ul>
<p>​		给定模式串DABCDABDE，我们很顺利的求得字符D之前的“DABCDAB”的各个子串的最长相同前缀后缀的长度分别为0 0 0 0 1 2 3，但当遍历到字符D，要求包括D在内的“DABCDABD”最长相同前缀后缀时，我们发现pj处的字符D跟pk处的字符C不一样，换言之，前缀DABC的最后一个字符C 跟后缀DABD的最后一个字符D不相同，所以不存在长度为4的相同前缀后缀。</p>
<p>​		怎么办呢？既然没有长度为4的相同前缀后缀，咱们可以寻找长度短点的相同前缀后缀，最终，因在p0处发现也有个字符D，p0 &#x3D; pj，所以p[j]对应的长度值为1，相当于E对应的next 值为1（即字符E之前的字符串“DABCDABD”中有长度为1的相同前缀和后缀）。</p>
<p>综上，可以通过递推求得next 数组，代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetNext</span><span class="hljs-params">(<span class="hljs-type">char</span>* p,<span class="hljs-type">int</span> next[])</span></span>&#123;<br>	<span class="hljs-type">int</span> pLen = <span class="hljs-built_in">strlen</span>(p);<br>	next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>	<span class="hljs-type">int</span> k = <span class="hljs-number">-1</span>;<br>	<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (j &lt; pLen - <span class="hljs-number">1</span>)&#123;<br>		<span class="hljs-comment">//p[k]表示前缀，p[j]表示后缀</span><br>		<span class="hljs-keyword">if</span> (k == <span class="hljs-number">-1</span> || p[j] == p[k]) &#123;<br>			++k;<br>			++j;<br>			next[j] = k;<br>		&#125;<span class="hljs-keyword">else</span> &#123;<br>			k = next[k];<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="基于《next-数组》匹配"><a href="#基于《next-数组》匹配" class="headerlink" title="基于《next 数组》匹配"></a>基于《next 数组》匹配</h5><p>下面，我们来基于next 数组进行匹配。</p>
 <img src="20140721231622000" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;" />

<p>还是给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示：</p>
 <img src="20140723224710203-1664503719079" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />

<p>在正式匹配之前，让我们来再次回顾下上文2.1节所述的KMP算法的匹配流程：</p>
<ul>
<li>假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置<ul>
<li>如果j &#x3D; -1，或者当前字符匹配成功（即S[i] &#x3D;&#x3D; P[j]），都令i++，j++，继续匹配下一个字符；</li>
<li>如果j !&#x3D; -1，且当前字符匹配失败（即S[i] !&#x3D; P[j]），则令 i 不变，j &#x3D; next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。</li>
</ul>
</li>
<li>换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值，即移动的实际位数为：j - next[j]，且此值大于等于1。”</li>
</ul>
<ol>
<li>最开始匹配时</li>
</ol>
<ul>
<li><p>P[0]跟S[0]匹配失败<br>所以执行“如果j !&#x3D; -1，且当前字符匹配失败（即S[i] !&#x3D; P[j]），则令 i 不变，j &#x3D; next[j]”，所以j &#x3D; -1，故转而执行“如果j &#x3D; -1，或者当前字符匹配成功（即S[i] &#x3D;&#x3D; P[j]），都令i++，j++”，得到i &#x3D; 1，j &#x3D; 0，即P[0]继续跟S[1]匹配。</p>
</li>
<li><p>P[0]跟S[1]又失配，j再次等于-1，i、j继续自增，从而P[0]跟S[2]匹配。</p>
</li>
<li><p>P[0]跟S[2]失配后，P[0]又跟S[3]匹配。</p>
</li>
<li><p>P[0]跟S[3]再失配，直到P[0]跟S[4]匹配成功，开始执行此条指令的后半段：“如果j &#x3D; -1，或者当前字符匹配成功（即S[i] &#x3D;&#x3D; P[j]），都令i++，j++”。</p>
 <img src="20140726213602848-1664503828241" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" /></li>
</ul>
<ol start="2">
<li><p>P[1]跟S[5]匹配成功，P[2]跟S[6]也匹配成功, …，直到当匹配到P[6]处的字符D时失配（即S[10] !&#x3D; P[6]），由于P[6]处的D对应的next 值为2，所以下一步用P[2]处的字符C继续跟S[10]匹配，相当于向右移动：j - next[j] &#x3D; 6 - 2 &#x3D;4 位。</p>
 <img src="20140721223809617-1664503879513" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />
</li>
<li><p>向右移动4位后，P[2]处的C再次失配，由于C对应的next值为<strong>0</strong>，所以下一步用**P[0]**处的字符继续跟S[10]匹配，相当于向右移动：j - next[j] &#x3D; 2 - 0 &#x3D; 2 位。</p>
 <img src="20140721223539765-1664503894803" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />
</li>
<li><p>移动两位之后，A 跟空格不匹配，模式串后移1 位。</p>
 <img src="20140721223823548-1664503912612" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />
</li>
<li><p>P[6]处的D再次失配，因为P[6]对应的next值为<strong>2</strong>，故下一步用**P[2]**继续跟文本串匹配，相当于模式串向右移动 j - next[j] &#x3D; 6 - 2 &#x3D; 4 位。</p>
 <img src="20140721223558140-1664503928624" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" />
</li>
<li><p>匹配成功，过程结束。</p>
 <img src="20140721223611515-1664503944938" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%;" /></li>
</ol>
<h5 id="Next-数组的优化"><a href="#Next-数组的优化" class="headerlink" title="Next 数组的优化"></a>Next 数组的优化</h5><p>​		行文至此，咱们全面了解了暴力匹配的思路、KMP算法的原理、流程、流程之间的内在逻辑联系，以及next 数组的简单求解（《最大长度表》整体右移一位，然后初值赋为-1）和代码求解，最后基于《next 数组》的匹配，看似洋洋洒洒，清晰透彻，但以上忽略了一个小问题。</p>
<p>​		比如，如果用之前的next 数组方法求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1（0 0 1 2整体右移一位，初值赋为-1），当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移 j - next[j] &#x3D; 3 - 1 &#x3D;2位。</p>
 <img src="aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTA2LzE0LzgzOTQzMjNfMTMwODA3NTg1OVpmdWUuanBn.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;" />

<p>​		右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] &#x3D; b，与s[3] &#x3D; c失配，而右移两位之后，让p[ next[3] ] &#x3D; p[1] &#x3D; b 再跟s[3]匹配时，必然失配。问题出在哪呢？</p>
 <img src="aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTA2LzE0LzgzOTQzMjNfMTMwODA3NTg1OTFreVYuanBn.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;" />

<p>​		问题出在不该出现 p[j] &#x3D; p[ next[j] ] 。为什么呢？理由是：当p[j] !&#x3D; s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] &#x3D; p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后你还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] &#x3D; p[ next[j ]]。如果出现了p[j] &#x3D; p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] &#x3D; next[ next[j] ]。</p>
<p>所以，咱们得修改下求next 数组的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//优化过后的next 数组求法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetNextval</span><span class="hljs-params">(<span class="hljs-type">char</span>* p, <span class="hljs-type">int</span> next[])</span></span>&#123;<br>	<span class="hljs-type">int</span> pLen = <span class="hljs-built_in">strlen</span>(p);<br>	next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>	<span class="hljs-type">int</span> k = <span class="hljs-number">-1</span>;<br>	<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (j &lt; pLen - <span class="hljs-number">1</span>)&#123;<br>		<span class="hljs-comment">//p[k]表示前缀字符，p[j]表示后缀字符  </span><br>		<span class="hljs-keyword">if</span>( k == <span class="hljs-number">-1</span> || p[j] == p[k] )&#123;<br>            <span class="hljs-comment">//疑惑：k==-1时什么情况？</span><br>            <span class="hljs-comment">//答疑：k==-1代表前面没有公共前后缀了</span><br>            ++k;<br>            ++j;<br>            <span class="hljs-comment">//较之前next数组求法，改动在下面4行</span><br>			<span class="hljs-keyword">if</span> (p[j] == p[k])<br>                <span class="hljs-comment">//因为不能出现p[j] = p[next[j]]，	</span><br>                <span class="hljs-comment">//所以当出现时需要继续递归，k = next[k] = next[next[k]]</span><br>				next[j] = next[k];<br>			<span class="hljs-keyword">else</span><br>				next[j] = k;   <span class="hljs-comment">//之前只有这一行</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            k = next[k];<br>        &#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​		利用优化过后的next 数组求法，可知模式串“abab”的新next数组为：-1 0 -1 0。可能有些读者会问：原始next 数组是前缀后缀最长公共元素长度值右移一位， 然后初值赋为-1而得，那么优化后的next 数组如何快速心算出呢？实际上，只要求出了原始next 数组，便可以根据原始next 数组快速求出优化后的next 数组。还是以abab为例，如下表格所示：</p>
 <img src="20140801160510832-1664504307010" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%;" />

<p>​		只要出现了p[next[j]] &#x3D; p[j]的情况，则把next[j]的值再次递归。例如在求模式串“abab”的第2个a的next值时，如果是未优化的next值的话，第2个a对应的next值为0，相当于第2个a失配时，下一步匹配模式串会用p[0]处的a再次跟文本串匹配，必然失配。所以求第2个a的next值时，需要再次递归：next[2] &#x3D; next[ next[2] ] &#x3D; next[0] &#x3D; -1（此后，根据优化后的新next值可知，第2个a失配时，执行“如果j &#x3D; -1，或者当前字符匹配成功（即S[i] &#x3D;&#x3D; P[j]），都令i++，j++，继续匹配下一个字符”），同理，第2个b对应的next值为0。</p>
<p>​		对于优化后的next数组可以发现一点：如果模式串的前后缀相同，那么它们的next值也是相同的，例如模式串abcabc，它的前缀后缀都是abc，其优化后的next数组为：-1 0 0 -1 0 0，前缀后缀abc的next值都为-1 0 0。</p>
<p>然后引用下之前3.1节的KMP代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KmpSearch</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, <span class="hljs-type">char</span>* p)</span></span>&#123;<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> sLen = <span class="hljs-built_in">strlen</span>(s);<br>	<span class="hljs-type">int</span> pLen = <span class="hljs-built_in">strlen</span>(p);<br>	<span class="hljs-keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;<br>		<span class="hljs-comment">//如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    </span><br>		<span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s[i] == p[j])&#123;<br>			i++;<br>			j++;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-comment">//如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span><br>			<span class="hljs-comment">//next[j]即为j所对应的next值      </span><br>			j = next[j];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (j == pLen)<br>		<span class="hljs-keyword">return</span> i - j;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来，咱们继续拿之前的例子说明，整个匹配过程如下：</p>
<ol>
<li><p>S[3]与P[3]匹配失败。</p>
 <img src="aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTA2LzE0LzgzOTQzMjNfMTMwODA3NTg1NzE0bFcuanBn.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;" />
</li>
<li><p>S[3]保持不变，P的下一个匹配位置是P[next[3]]，而next[3]&#x3D;0，所以P[next[3]]&#x3D;P[0]与S[3]匹配。</p>
 <img src="aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTA2LzE0LzgzOTQzMjNfMTMwODA3NTg1NzEzOTAuanBn.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;" />
</li>
<li><p>由于上一步骤中P[0]与S[3]还是不匹配。此时i&#x3D;3，j&#x3D;next [0]&#x3D;-1，由于满足条件j&#x3D;&#x3D;-1，所以执行“++i, ++j”，即主串指针下移一个位置，P[0]与S[4]开始匹配。最后j&#x3D;&#x3D;pLen，跳出循环，输出结果i - j &#x3D; 4（即模式串第一次在文本串中出现的位置），匹配成功，算法结束。</p>
 <img src="aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTA2LzE0LzgzOTQzMjNfMTMwODA3NTg1N2U0MHUuanBn.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;" /></li>
</ol>
<h4 id="快速求next数组"><a href="#快速求next数组" class="headerlink" title="快速求next数组*"></a>快速求next数组*</h4><p>​		快速构建next数组，是KMP算法的精髓所在，核心思想是“<strong>P自己与自己做匹配</strong>”。</p>
<p><strong>回顾next数组的完整定义：</strong></p>
<ul>
<li>定义 “k-前缀” 为一个字符串的前 k 个字符； “k-后缀” 为一个字符串的后 k 个字符。k 必须小于字符串长度。</li>
<li>next[x] 定义为： P[0]~P[x] 这一段字符串，使得<strong>k-前缀恰等于k-后缀</strong>的最大的k.</li>
</ul>
<p>​		这个定义中，不知不觉地就包含了一个匹配——前缀和后缀相等。接下来，我们考虑采用递推的方式求出next数组。如果next[0], next[1], … next[x-1]均已知，那么如何求出 next[x] 呢？</p>
<p><strong>来分情况讨论：</strong></p>
<ul>
<li><p>首先，已经知道了 next[x-1]（以下记为now），如果 P[x] 与 P[now] 一样，那最长相等前后缀的长度就可以扩展一位，很明显 next[x] &#x3D; now + 1. 图示如下。</p>
<img src="v2-6d6a40331cd9e44bfccd27ac5a764618_720w.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 30%;" />
</li>
<li><p>刚刚解决了 P[x] &#x3D; P[now] 的情况。那如果 P[x] 与 P[now] 不一样，又该怎么办？</p>
<p>​		<strong>关键：</strong>前面已经匹配了的前缀与后缀是相同的，因此，在找新的公共前后缀时，只需在前缀上找最长公共前后缀即可。</p>
<p>​		如图。长度为 now 的子串 A 和子串 B 是 P[0]<del>P[x-1] 中最长的公共前后缀。可惜 A 右边的字符和 B 右边的那个字符不相等，next[x]不能改成 now+1 了。因此，我们应该<strong>缩短这个now</strong>，把它改成小一点的值，再来试试 P[x] 是否等于 P[now].<br>　　now该缩小到多少呢？显然，我们不想让now缩小太多。因此我们决定，在保持“P[0]</del>P[x-1]的now-前缀仍然等于now-后缀”的前提下，让这个新的now尽可能大一点。 P[0]~P[x-1] 的公共前后缀，前缀一定落在串A里面、后缀一定落在串B里面。换句话讲：接下来now应该改成：使得 <strong>A的k-前缀</strong>等于<strong>B的k-后缀</strong> 的最大的k.<br>　　您应该已经注意到了一个非常强的性质——<strong>串A和串B是相同的</strong>！B的后缀等于A的后缀！因此，使得A的k-前缀等于B的k-后缀的最大的k，其实就是串A的最长公共前后缀的长度 —— next[now-1]！</p>
 <img src="v2-c5ff4faaab9c3e13690deb86d8d17d71_720w.webp" srcset="/img/loading.gif" lazyload alt="img" style="zoom: 67%;" /></li>
</ul>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码*"></a>实现代码*</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Next的求解 代码1（来源CSDN：从头到尾彻底理解KMP）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetNext</span><span class="hljs-params">(<span class="hljs-type">char</span> *p, <span class="hljs-type">int</span> next[])</span></span>&#123;<br>    <span class="hljs-type">int</span> pLen = <span class="hljs-built_in">strlen</span>(p);<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(j &lt; pLen<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span>( k == <span class="hljs-number">-1</span> || p[j] == p[k] )&#123;<br>            <span class="hljs-comment">//疑惑：k==-1时什么情况？</span><br>            <span class="hljs-comment">//答疑：k==-1代表前面没有公共前后缀了</span><br>            ++k;<br>            ++j;<br>            <span class="hljs-comment">//较之前next数组求法，改动在下面4行</span><br>			<span class="hljs-keyword">if</span> (p[j] == p[k])<br>                <span class="hljs-comment">//因为不能出现p[j] = p[next[j]]，	</span><br>                <span class="hljs-comment">//所以当出现时需要继续递归，k = next[k] = next[next[k]]</span><br>				next[j] = next[k];<br>			<span class="hljs-keyword">else</span><br>				next[j] = k;   <span class="hljs-comment">//之前只有这一行</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            k = next[k];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//对应的KMP</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">KmpSearch</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, <span class="hljs-type">char</span>* p)</span></span>&#123;<br>    <span class="hljs-type">int</span> sLen = <span class="hljs-built_in">strlen</span>(s), pLen = <span class="hljs-built_in">strlen</span>(p);<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)&#123;<br>		<span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s[i] == p[j])&#123;  <br>            <span class="hljs-comment">//疑惑： j == -1 对应的情况时什么？  </span><br>            <span class="hljs-comment">//答疑：上一次匹配得出没有没有公共前后缀了，即next=0(该方法表现为-1)，需要s往后检测匹配了</span><br>            <span class="hljs-comment">//如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++ </span><br>			i++;<br>			j++;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-comment">//如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    </span><br>			<span class="hljs-comment">//next[j]即为j所对应的next值      </span><br>			j = next[j];<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span> (j == pLen)<br>		<span class="hljs-keyword">return</span> i - j;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Next的求解 代码2  	说明：对于j和k，相当于k在前缀，j在后缀</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetNext</span><span class="hljs-params">(<span class="hljs-type">char</span> *p, <span class="hljs-type">int</span> next[])</span></span>&#123;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> pLen = <span class="hljs-built_in">strlen</span>(p);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;pLen;j++)&#123;<br>        <span class="hljs-type">int</span> k = next[j];<br>        <span class="hljs-keyword">while</span>(k &amp;&amp; p[k]!=p[j])&#123;  <span class="hljs-comment">//本质：在前缀找 除去最后一位的最长共同前后缀</span><br>            k = next[k];<br>        &#125;<br>        next[j+<span class="hljs-number">1</span>] = (p[j]==p[k]) ? k+<span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-type">char</span> *s, <span class="hljs-type">char</span> *p)</span></span>&#123;<br>    <span class="hljs-type">int</span> last = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> sLen = <span class="hljs-built_in">strlen</span>(s), pLen = <span class="hljs-built_in">strlen</span>(p);<br>    <span class="hljs-built_in">getFail</span>(p,pLen);<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;slen;i++)&#123;<br>        <span class="hljs-keyword">while</span>( j &amp;&amp; s[i]!=p[j] )  j = next[j];<br>        <span class="hljs-keyword">if</span>(s[i]==p[j])  j++;<br>        <span class="hljs-keyword">if</span>(j==pLen)&#123;<br>            <span class="hljs-keyword">return</span> i-j;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h4><p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=2087">hdu 2087 剪花布条</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1010</span>;<br><span class="hljs-type">char</span> str[MAXN], pattern[MAXN];<br><span class="hljs-type">int</span> Next[MAXN];<br><span class="hljs-type">int</span> cnt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">char</span>* p)</span> </span>&#123;<br>	<span class="hljs-type">int</span> pLen = <span class="hljs-built_in">strlen</span>(p);<br>	Next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>	<span class="hljs-type">int</span> k = <span class="hljs-number">-1</span>;<br>	<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (j &lt; pLen - <span class="hljs-number">1</span>) &#123;<br>		<span class="hljs-keyword">if</span> (k == <span class="hljs-number">-1</span> || p[j] == p[k]) &#123;<br>			++j;<br>			++k;<br>			<span class="hljs-keyword">if</span> (p[j] == p[k]) &#123;<br>				Next[j] = Next[k];<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				Next[j] = k;<br>			&#125;<br><br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			k = Next[k];<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, <span class="hljs-type">char</span>* p)</span> </span>&#123;<br>	<span class="hljs-type">int</span> last = <span class="hljs-number">-1</span>;<br>	<span class="hljs-built_in">getNext</span>(p);<br>	<span class="hljs-type">int</span> sLen = <span class="hljs-built_in">strlen</span>(s), pLen = <span class="hljs-built_in">strlen</span>(p);<br>	<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span> (i &lt; sLen) &#123;<br>		<span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s[i] == p[j]) &#123;<br>			i++;<br>			j++;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			j = Next[j];<br>		&#125;<br>		<span class="hljs-keyword">if</span> (j == pLen &amp;&amp; i - last &gt;= pLen) &#123;<br>			cnt++;<br>			last = i;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str)) &#123;<br>		<span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, pattern);<br>		cnt = <span class="hljs-number">0</span>;<br>		<span class="hljs-built_in">kmp</span>(str, pattern);<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, cnt);<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>







<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/338414118">Dijkstra算法详解 通俗易懂 - 知乎 (zhihu.com)</a></p>
<blockquote>
<p>Dijkstra 算法是求一个图中一个点到其他所有点的最短路径的算法</p>
<p>阅读前请先了解图的数据结构「邻接矩阵」</p>
</blockquote>
<p>Dijkstra 算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法，时间复杂度 O(n2)。</p>
<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><p>每次从 「未求出最短路径的点」中 <strong>取出</strong> 距离距离起点 <strong>最小路径的点</strong>，以这个点为桥梁 <strong>刷新</strong>「未求出最短路径的点」的距离（看不懂没关系，请结合案例理解）</p>
<h4 id="图解案例分析"><a href="#图解案例分析" class="headerlink" title="图解案例分析"></a>图解案例分析</h4><blockquote>
<p>案例：以 A 点为顶点，求到其他点的最短路径。</p>
</blockquote>
<p><img src="/2021/11/25/AlgorithmNote/image-20221111114926574.png" srcset="/img/loading.gif" lazyload alt="image-20221111114926574"></p>
<p>邻接矩阵图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;<br>&#123;<span class="hljs-number">0</span> , <span class="hljs-number">2</span>, ∞, <span class="hljs-number">6</span>&#125;<br>&#123;<span class="hljs-number">2</span> , <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;<br>&#123;∞ , <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>&#125;<br>&#123;<span class="hljs-number">6</span> , <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>（重点）算法要点</strong></p>
<ul>
<li><strong>result：</strong> <strong>已求出</strong> 最小路径的顶点</li>
<li><strong>notFound：</strong> <strong>未求出</strong> 最小路径的顶点，里面的值是 <strong>到起点的距离</strong></li>
</ul>
<blockquote>
<p>每次从 「未求出最短路径的点」中 取出 距离距离起点 最近的点，以这个点为桥梁 刷新「未求出最短路径的点」的距离</p>
</blockquote>
<p>初始，<code>result=&#123;A(0)&#125;</code> 中只有起点 A，<code>notFound=&#123;B(2),C(∞),D(6)&#125;</code> 中是除了 A 点的其他点，里面的值是到起点的距离（例如 B(2) 代表 B点到起点的距离为 2）</p>
<p><img src="/2021/11/25/AlgorithmNote/image-20221111115011223.png" srcset="/img/loading.gif" lazyload alt="image-20221111115011223"></p>
<p><strong>然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 B(2) ，然后通过 B(2) 为桥梁 刷新「未求出最短路径的点」的距离</strong></p>
<ol>
<li><strong>取出 最短路径的点：</strong></li>
</ol>
<p>从「未求出最短路径的点」notFound 中取出 最短路径的点 B(2)，放入结果 result 中，结果如下：</p>
<p>「未求出最短路径点」 <code>notFound=&#123;C(∞),D(6)&#125;</code>，「已求出最短路径的点 」<code>result=&#123;A(0),B(2)&#125;</code></p>
<ol>
<li><strong>刷新距离</strong>：</li>
</ol>
<p>通过 B(2) 为桥梁，刷新距离。</p>
<p>例如 <code>AD = 6 &lt; AB + BD = 4</code> 以 B(2) 为桥梁的距离更短，就刷新「未求出最短路径点」D(6) 的距离为 D(4)</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">notFound</span>=&#123;C(∞),D(<span class="hljs-number">4</span>)&#125;<br></code></pre></td></tr></table></figure>

<p>同理刷新 C(∞) 的距离为 C(5) ，最后结果如下：</p>
<p>「未求出最短路径点」 <code>notFound=&#123;C(5),D(4)&#125;</code> ，「已求出最短路径的点」<code>result=&#123;A(0),B(2)&#125;</code> </p>
<p><img src="/2021/11/25/AlgorithmNote/image-20221111115053104.png" srcset="/img/loading.gif" lazyload alt="image-20221111115053104"></p>
<p><strong>然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 D(4) ，然后通过 D(4) 为桥梁 刷新「未求出最短路径的点」的距离</strong></p>
<p>同理，最后结果如下：</p>
<p>「未求出最短路径点」 <code>notFound=&#123;C(5)&#125;</code> ，「已求出最短路径的点」<code>result=&#123;A(0),B(2),D(4)&#125;</code></p>
<p><img src="/2021/11/25/AlgorithmNote/image-20221111115111128.png" srcset="/img/loading.gif" lazyload alt="image-20221111115111128"></p>
<p><strong>然后，从「未求出最短路径的点」notFound 中取出 最短路径的点 C(5) ，算法结束</strong></p>
<p><strong><code>result=&#123;A(0),B(2),D(4),C(5)&#125;</code> 就是最终所求的 最短距离</strong></p>
<p><img src="/2021/11/25/AlgorithmNote/image-20221111115126718.png" srcset="/img/loading.gif" lazyload alt="image-20221111115126718"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>这里使用 -1 表无穷大，下面是 Java 代码和测试案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dijkstra</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] dijkstra(<span class="hljs-type">int</span>[][] graph,<span class="hljs-type">int</span> startVertex)&#123;<br>        <span class="hljs-comment">//初始化 以求出最短路径的点 result[]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> graph.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            result[i] = -<span class="hljs-number">1</span>;<br>        &#125;<br>        result[startVertex] = <span class="hljs-number">0</span> ;<br>        <span class="hljs-comment">// 初始化 未求出最短路径的点 notFound[]</span><br>        <span class="hljs-type">int</span>[] notFound = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            notFound[i] = graph[startVertex][i];<br>        &#125;<br>        notFound[startVertex] = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 开始 Dijkstra 算法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">//1. 从「未求出最短路径的点」notFound 中取出 最短路径的点</span><br>            <span class="hljs-comment">//1.1 找到最短距离的点</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (notFound[j] &gt; <span class="hljs-number">0</span> &amp;&amp; notFound[j] &lt; min)&#123;<br>                    min = notFound[j];<br>                    minIndex = j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//1.2 将最短距离的点 取出 放入结果中</span><br>            result[minIndex] = min;<br>            notFound[minIndex] = -<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//2. 刷新 「未求出最短距离的点」 notFound[] 中的距离</span><br>            <span class="hljs-comment">//2.1 遍历刚刚找到最短距离的点 (B) 的出度 (BA、BB、BC、BD)</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; length; j++) &#123;<br>                <span class="hljs-comment">// 出度可通行(例如 BD:graph[1][3]  &gt; 0)</span><br>                <span class="hljs-comment">// 出度点不能已经在结果集 result中(例如 D: result[3] == -1)</span><br>                <span class="hljs-keyword">if</span> (graph[minIndex][j] &gt; <span class="hljs-number">0</span><br>                &amp;&amp; result[j] == -<span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">newDistance</span> <span class="hljs-operator">=</span> result[minIndex] + graph[minIndex][j];<br>                    <span class="hljs-comment">//通过 B 为桥梁，刷新距离</span><br>                    <span class="hljs-comment">//（比如`AD = 6 &lt; AB + BD = 4` 就刷新距离）（ -1 代表无限大）</span><br>                    <span class="hljs-keyword">if</span> (newDistance &lt; notFound[j] || notFound[j]==-<span class="hljs-number">1</span>)&#123;<br>                        notFound[j] = newDistance;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-comment">/** 测试案例 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">char</span>[] vertices = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>&#125;;<br>        <span class="hljs-type">int</span>[][] graph = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;<br>                &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">6</span>&#125;<br>                , &#123;<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;<br>                , &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>&#125;<br>                , &#123;<span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;&#125;;<br>        <span class="hljs-type">int</span>[] dijkstra = dijkstra(graph, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : dijkstra) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*测试结果</span><br><span class="hljs-comment">    0</span><br><span class="hljs-comment">    2</span><br><span class="hljs-comment">    5</span><br><span class="hljs-comment">    4</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>






















                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Algorithm</div>
      <div>https://leung-yh.github.io/2021/11/25/AlgorithmNote/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Leungyh</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年11月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/30/JavaNote/" title="Java基础">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://github.com/Leung-Yh" target="_blank" rel="nofollow noopener"><span>Github</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
